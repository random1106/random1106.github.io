<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Yier Lin</title>
  <meta name="description" content="CTF writeup for SmileyCTF 2025: Never Enough" />
  <link href="/assets/css/main.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css">
  <script src="/assets/js/math.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>
</head>

<body>
  <div class="wrap">

  <header class="site-header">
    <div class="logo">
    <h1>SmileyCTF 2025 — Never Enough</h1>
    </div>
    <nav class="navbar">
        <a href="/index.html">Home</a>
        <a href="/security/writeups/index.html">Writeup</a>
    </nav>
  </header>

    <hr>

    <main id="top">
      <img class="responsive" src="/assets/img/neverenough.png" alt="neverenough.png"></img>

        <section>
        <h2 id="solution"> Solution </h2>
        
        <p>
            The goal is to recover the flag given the output generated from the following:
        </p>
<pre><code class="language-python">
from random import getrandbits
from Crypto.Cipher import AES
from hashlib import sha256
danger = 624*32 # i hear you need this much.
given = []
key = ""
for _ in range(danger//20 - 16): # should be fine if im only giving u this much :3
    x = getrandbits(32)
    # we share <3
    key += str(x % 2**12)
    given.append(x >> 12)

key = key[:100]
key = sha256(key.encode()).digest()
flag = open("flag.txt", "rb").read().strip()
cipher = AES.new(key, AES.MODE_ECB)
print(given)
print(cipher.encrypt(flag + b"\x00" * (16 - len(flag) % 16)).hex())
</code></pre>

<p>
The background story is that Python’s random package generates random numbers using the MT19937 (there is some small difference but does not matter here), which maintains 624 internal state variables. In python, the first 624 random numbers are generated by applying a tempering function (which is a one-to-one mapping) to these states. After 624 numbers are generated, the states are updated via a twist operation that update the internal state (Unlike temper, the twist operation is generally not reversible).
</p>

<p>
MT19937 has a period of 2¹⁹⁹³⁷-1, which is effectively impossible to exhaust in practice. However, if we can recover the initial 624 state variables, we can fully clone the random number generator. Since the tempering function is one-to-one, if we observe 624 full 32-bit outputs, we can reverse the tempering and reconstruct the internal state.
</p>

<p>
In our challenge, we are given 982 outputs, but only the upper 20 bits of each output. Our goal is to recover the missing lower 12 bits of the first few outputs in order to reconstruct a key of length 100.
</p>

<p>
We found a relevant GitHub repository: https://github.com/icemonster/symbolic_mersenne_cracker
</p>

<p>
The basic idea behind the code is that, although knowing only the upper 20 bits of each output is not enough to directly recover the MT states, we have more than 624 outputs. This allows us to formulate a system of equations and use the Z3 solver to find a solution.
</p>

<p>
The repository performs a closely related task, but it focuses on predicting future random outputs rather than finding the original MT state. This is not exactly what we need, so we made slight modifications to the code to suit our purpose. So we need to modify it a little bit.
</p>

<pre><code class="language-python"># code modified from https://github.com/icemonster/symbolic_mersenne_cracker
from z3 import *
from random import Random
from itertools import count
from time import time
import logging

logging.basicConfig(format='STT> %(message)s')
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

SYMBOLIC_COUNTER = count()

class Untwister:
    def __init__(self):
        name = next(SYMBOLIC_COUNTER)
        self.MT = [BitVec(f'MT_{i}_{name}', 32) for i in range(624)]
        self.index = 0
        self.solver = Solver()

    #This particular method was adapted from https://www.schutzwerk.com/en/43/posts/attacking_a_random_number_generator/
    def symbolic_untamper(self, solver, y):
        name = next(SYMBOLIC_COUNTER)

        y1 = BitVec(f'y1_{name}', 32)
        y2 = BitVec(f'y2_{name}' , 32)
        y3 = BitVec(f'y3_{name}', 32)
        y4 = BitVec(f'y4_{name}', 32)

        equations = [
            y2 == y1 ^ (LShR(y1, 11)),
            y3 == y2 ^ ((y2 << 7) & 0x9D2C5680),
            y4 == y3 ^ ((y3 << 15) & 0xEFC60000),
            y == y4 ^ (LShR(y4, 18))
        ]

        solver.add(equations)
        return y1

    def symbolic_twist(self, MT, n=624, upper_mask=0x80000000, lower_mask=0x7FFFFFFF, a=0x9908B0DF, m=397):
        '''
            This method models MT19937 function as a Z3 program
        '''
        MT = [i for i in MT] #Just a shallow copy of the state

        for i in range(n):
            x = (MT[i] & upper_mask) + (MT[(i+1) % n] & lower_mask)
            xA = LShR(x, 1)
            xB = ((x & 1) * a) ^ xA #Possible Z3 optimization here by declaring auxiliary symbolic variables
            MT[i] = MT[(i + m) % n] ^ xB

        return MT

    def get_symbolic(self, guess):
        name = next(SYMBOLIC_COUNTER)
        ERROR = 'Must pass a string like "?1100???1001000??0?100?10??10010" where ? represents an unknown bit'

        assert type(guess) == str, ERROR
        assert all(map(lambda x: x in '01?', guess)), ERROR
        assert len(guess) <= 32, "One 32-bit number at a time please"
        guess = guess.zfill(32)

        self.symbolic_guess = BitVec(f'symbolic_guess_{name}', 32)
        guess = guess[::-1]

        for i, bit in enumerate(guess):
            if bit != '?':
                self.solver.add(Extract(i, i, self.symbolic_guess) == bit)

        return self.symbolic_guess


    def submit(self, guess):
        '''
            You need 624 numbers to completely clone the state.
                You can input less than that though and this will give you the best guess for the state
        '''
        if self.index >= 624:
            self.pre_twist_MT = self.MT.copy()
            name = next(SYMBOLIC_COUNTER)
            next_mt = self.symbolic_twist(self.MT)
            self.MT = [BitVec(f'MT_{i}_{name}', 32) for i in range(624)]
            for i in range(624):
                self.solver.add(self.MT[i] == next_mt[i])
            self.index = 0

        symbolic_guess = self.get_symbolic(guess)
        symbolic_guess = self.symbolic_untamper(self.solver, symbolic_guess)
        self.solver.add(self.MT[self.index] == symbolic_guess)
        self.index += 1

    def get_random(self):
        '''
            This will give you a random.Random() instance with the cloned state.
        '''
        logger.debug('Solving...')
        start = time()
        self.solver.check()
        model = self.solver.model()
        end = time()
        logger.debug(f'Solved! (in {round(end-start,3)}s)')
        
        # our modification

        state = list(map(lambda x: model[x].as_long(), [BitVec(f'MT_{i}_0', 32) for i in range(624)])) 
        result_state = (3, tuple(state+[0]), None)

        # modification done        

        r = Random()
        r.setstate(result_state)
        return r

We test this code by generating 982 random numbers and checking whether the first 100 outputs match our results. Since the key is only 100 bytes long, the first 100 outputs are sufficient.

r = Random()
r.seed(0) # can change this seed for further testing

ut = Untwister()
res = []
for _ in range(982):
    num = r.getrandbits(32)
    res.append(num)
    ut.submit(bin(num >> 12)[2:].zfill(20) + '?'*12)

r2 = ut.get_random()

for i in range(100):
    if r2.getrandbits(32) != res[i]:
        print(f"The index {i} is not recovered correctly")
</code></pre>

<p>
We observed that the output The index 0 is not recovered correctly. Changing the seed in most tests produces the same result. Although we do not fully understand why, we are fairly confident that, given the data, we only need to skip index 0 and can use the outputs from indices 1 to 99.
</p>

<p>
In the final part of our code, we brute-force the lower 12 bits of the first output and prepend them to the key formed from the rest of the generator’s output. We then use AES in ECB mode to decrypt and filter the message, checking whether it matches the beginning or the end of the flag. We also check for known padding at the end as an alternative validation.
</p>

<pre><code class="language-python">
from Crypto.Cipher import AES
from hashlib import sha256

ut = Untwister()
res = []
for num in lst:
    ut.submit(bin(num)[2:].zfill(20) + '?'*12)

r2 = ut.get_random()

pkey = ""
for i in range(982):
    if i == 0: # skip the zeroth index
        r2.getrandbits(32)
        continue
    pkey += str(r2.getrandbits(32) % 2**12)

for i in range(2**12):
    key = (str(i) + pkey)[:100]
    key = sha256(key.encode()).digest()
    cipher = AES.new(key, AES.MODE_ECB)
    if cipher.decrypt(bytes.fromhex(s))[:5] == b".;,;.":
        print(cipher.decrypt(bytes.fromhex(s))) 
</code></pre>

<p>
We recover the flag <code>.;,;.{never_enough_but_you_gotta_just_make_more_or_something_idk_im_not_a_motivational_
    <br>
    speaker_but_you_get_the_idea}</code>
</p>

<p>
Lesson: Even without knowing all 624 full 32-bit outputs, it is still possible to partially recover the MT state if we have a larger number of outputs and even partially masked bits. Therefore, masking the output is not a secure way to protect against MT19937 state recovery.
</p>
        


      </section>

        <footer>
          <hr />
          <p class="muted">© Yier Lin 2025</p>
      </footer>

    </main>
  </div>




  <button id="backTop" type="button" aria-label="Back to top">Back to Top ↑</button>


  <script>
    (function(){
      const btn = document.getElementById('backTop');
      const onScroll = () => {
        if (window.scrollY > 400) btn.classList.add('show');
        else btn.classList.remove('show');
      };
      window.addEventListener('scroll', onScroll, { passive: true });
      btn.addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));
      onScroll();
    })();
  </script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <script src="/assets/js/code.js"></script>



</body>

</html>